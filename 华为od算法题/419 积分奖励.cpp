///*
//419 执行任务赚积分 / 积分奖励
//题目描述：
//现有N个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。
//每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
//可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。
//输入描述：
//第一行为一个数N，表示有N个任务，1<=N<=100
//第二行为一个数T，表示可用于处理任务的时间。1<=T<=100
//接下来N行，每行两个空格分隔的整数(SLA和V)，SLA表示任务的最晚处理时间，V表  示任务对应的积分。1<=SLA<=100, 0<=V<=100000
//
//输出描述：可获得的最多积分
//
//示例1
//输入：
//4
//3
//1 2
//1 3
//1 4
//1 5
//输出：5
//说明：
//虽然有3个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。
//所以在第1个时间单位内，选择处理有 5 个积分的任务。1-3 时无任务处理。
//
//示例2
//输入：
//4
//3
//1 2
//1 3
//1 4
//3 5
//输出：9
//说明：
//第1个时间单位内，处理任务3，获得4个积分
//第2个时间单位内，处理任务4，获得5个积分
//第3个时间单位内，无任务可处理
//共获得9个积分
//
//思路：
//	在有限的时间内，赚取最大的积分。
//
//思路2：
//我们可以把任务按照时间从小到大的顺序排序，维护一个小根堆表示我们最终要去处理的这些任务
//	由于每次处理任务需要耗时1，因此最多只能处理 T 个任务，小根堆中元素的数量不能大于 T。
//	当遍历到第 i 个事件，首先我们需要去比较第 i 个事件的过期时间 t 是否比小根堆中的元素数量要大，如果大的话，判断小根堆是否满，如果没满，就可以直接加入到小根堆中，如果满了，则需要跟小根堆堆顶元素比较大小，如果比堆顶元素大，则可以将堆顶元素弹出，将当前元素添加到小根堆中
//	如果发现第 i 个事件的过期时间 t 是否比小根堆中的元素数量要小（就是出现了样例1中有多个事件在同一时间截止，但是最多只能处理一个的情况），则需要跟小根堆堆顶元素比较大小，如果比堆顶元素大，则可以将堆顶元素弹出，将当前元素添加到小根堆中
//			如何保证当前弹出的元素的位置就符合当前添加的元素呢？
//			因为先按顺序将所有的数据进行了排序，因此当前数据之前的数据至少都比当前的数据更早到期。因此加入一个晚到期的数据一定能够替换早到期的数据。
//假如 2
//1 1
//1 3
//1 5
//1 6
//2 2
//2 4
//
//1 5
//1 6
//*/
//
//#include<iostream>
//#include<vector>
//#include<queue>
//#include<algorithm>
//
//using namespace std;
//
//int main()
//{
//	// 输入
//	int n;	// N个任务
//	int t;	// 可用于处理任务的时间
//	cin >> n >> t;
//	vector<pair<int, int>> v;	// SLA表示任务的最晚处理时间，V表示任务对应的积分
//	for (int i = 0; i < n; i++)
//	{
//		int a, b;
//		cin >> a >> b;
//		v.push_back({ a, b });
//	}
//	sort(v.begin(), v.end());	// 按照处理事件先后顺序从小到大排序
//	priority_queue<int, vector<int>, greater<int>> heap;  // 定义小根堆	维护的小根堆大小不能超过t
//	for (int i = 0; i < n; i++)	// 遍历所有任务
//	{
//		if (v[i].first > heap.size())	// 当前任务的时间期限比当前的堆大。也就是说不管堆后续如何变化，当前任务肯定会被执行。
//		{
//			if (heap.size() < t)	// 堆未满，可以直接加入
//			{
//				heap.push(v[i].second);
//			}
//			else if(v[i].second > heap.top()){	// 堆满了，如果当前任务价值比堆顶大
//				heap.pop();
//				heap.push(v[i].second);
//			}
//		}
//		else {	// 任务过期咯
//			if (v[i].second > heap.top())
//			{
//				heap.pop();
//				heap.push(v[i].second);
//			}
//		}
//	}
//	int count = 0;
//	while (!heap.empty())
//	{
//		count += heap.top();
//		heap.pop();
//	}
//	cout << count;
//
//}